#!/usr/bin/env python
import os
from os.path import join as pjoin, abspath, isdir, isfile, dirname
import sys
import subprocess
import re
from optparse import OptionParser


def add(name, location):
    remotes = [r.strip() for r in shrun('git remote show').split('\n')]
    if name in remotes:
        raise OSError("There is already a remote with that name")
    if shrun('git config git-bzr.%(name)s.location' % locals()) != "":
        raise OSError("There is alread a git-bzr branch with that name")
    if not isdir(pjoin(location, ".bzr")):
        raise OSError("%(location)s is not a bazaar repository" %
                      locals())
    shrun('git config git-bzr.%(name)s.location %(location)s' %
          locals())
    print "Bazaar branch %(name)s added. You can fetch it with " \
              "`git bzr fetch %(name)s`" % locals()


def _get_filter(remote,include=False,exclude=False):

    update=True
    map_dir = get_map_dir(remote)
    print "map_dir:", map_dir
    if not include and not exclude:
        f = open( map_dir +"/include", 'r')
        include = f.readall()
        f.close()
        f = open( map_dir +"/exclude", 'r')
        exclude = f.readall()
        f.close()
        update=False

    if update:
        if include:
            f = open( map_dir +"/include", 'w+')
            f.write(include)
            f.close()
        if exclude:
            f = open( map_dir +"/exclude", 'w+')
            f.write(exclude)
            f.close()

    bzr_filter=[]
    if include:
        bzr_filter+=['-i %s'%include]
    if exclude:
        bzr_filter+=[' -x %s'%exclude]

    if bzr_filter:
        bzr_filter = " ".join(bzr_filter)
        bzr_filter = 'bzr fast-import-filter %s |'%bzr_filter
    else:
        bzr_filter = ""

    return bzr_filter


def fetch(remote, include=False, exclude=False):
    print "remote",remote, "ilter:",include, exclude
    location = get_location(remote)
    git_map, bzr_map = get_maps(remote)
    if not isfile(git_map) and not isfile(bzr_map):
        print "There doesn't seem to be an existing refmap. "
        print "Doing an initial import"
        map_name = dirname(git_map)
        if not isdir(map_name):
            os.makedirs(map_name)

        bzr_filter = _get_filter(remote,include,exclude)

        shcall('(bzr fast-export '
               '--plain '
               '--export-marks=%(bzr_map)s '
               '--git-branch=bzr/%(remote)s '
               '%(location)s) | '
               '%(bzr_filter)s '
               'sed "s/reset\ refs\/tags\/version\ /reset\ refs\/tags\//" | '
               '(git fast-import '
               '--export-marks=%(git_map)s)'
             % locals())

    elif isfile(git_map) and isfile(bzr_map):
        print 'Updating remote', remote
        _do_colons(bzr_map, bzr_map, 'remove')
        old_rev = rev_parse('bzr/%s' % remote)
        bzr_filter = _get_filter(remote)
        shcall('(bzr fast-export '
               '--plain '
               '--import-marks=%(bzr_map)s '
               '--export-marks=%(bzr_map)s '
               '--git-branch=bzr/%(remote)s '
               '%(location)s) | '
               '%(bzr_filter)s '
               '(git fast-import '
               '--quiet '
               '--export-marks=%(git_map)s '
               '--import-marks=%(git_map)s)'
               % locals())
        new_rev = rev_parse('bzr/%s' % remote)
        print "Changes since last update:"
        print shrun('git shortlog %s..%s' % (old_rev, new_rev))
    else:
        raise OSError("One of the mapfiles is missing! "
                      "Something went wrong!")
    

def _do_colons(in_fname, out_fname, action='add'):
    ''' Add or remove colons to / from front of commit numbers '''
    in_f = open(in_fname, 'rt')
    lines = []
    if action == 'add':
        regex = re.compile(r'^(\d+ )')
        substr = r':\1'
    elif action == 'remove':
        regex = re.compile(r'^:(\d+ )')
        substr = r'\1'
    for line in in_f:
        lines.append(regex.sub(substr, line))
    in_f.close()
    out_f = open(out_fname, 'wt')
    out_f.writelines(lines)
    out_f.close()
    

def push(remote):
    location = get_location(remote)
    lst = shrun('git rev-list --left-right HEAD...bzr/%s' % remote)
    if lst.startswith('>'):
        raise OSError("HEAD is not a strict child of %s, "
                      "cannot push. Merge first" % remote)
    if not lst.startswith('<'):
        raise OSError("Nothing to push. Commit something first")
    git_map, bzr_map = get_maps(remote)
    if not isfile(git_map) or not isfile(bzr_map):
        raise OSError("We do not have refmapping yet. "
                      "Then how can I push?")
    bzr_map_colons = bzr_map + '_colons'
    _do_colons(bzr_map, bzr_map, 'add')
    shcall('(git fast-export '
         '--import-marks=%(git_map)s '
         '--export-marks=%(git_map)s '
         'HEAD) | '
         '(cd %(location)s && '
         'bzr fast-import '
         '--import-marks=%(bzr_map)s '
         '--export-marks=%(bzr_map)s -)' % locals())


def shrun(cmd, ret_error=False, ret_code=False):
    proc = subprocess.Popen(cmd,
                 stdout=subprocess.PIPE,
                 stderr=subprocess.PIPE,
                 shell=True)
    (out, err) = proc.communicate()
    if not (ret_error or ret_code):
        return out
    ret = [out]
    if ret_error:
        ret.append(err)
    if ret_code:
        ret.append(proc.returncode)
    return ret


def shcall(cmd):
    return subprocess.check_call(cmd, shell=True)

def get_map_dir(remote):
    git_dir = abspath(get_git_dir())
    map_dir = pjoin(git_dir, 'bzr-git')
    return map_dir

def get_maps(remote):
    git_dir = abspath(get_git_dir())
    map_dir = pjoin(git_dir, 'bzr-git')
    git_map = pjoin(map_dir, '%s-git-map' % remote)
    bzr_map = pjoin(map_dir, '%s-bzr-map' % remote)
    return git_map, bzr_map


def get_location(remote):
    out = shrun('git config git-bzr.%s.location' % remote).strip()
    if out == "":
        raise OSError("Cannot find bazaar remote with name `%(s`."
                      % remote)
    return out


def get_git_dir():
    return rev_parse('--git-dir')


def rev_parse(arg):
    return shrun('git rev-parse %s' % arg).strip()


def to_git_root():
    out, code = shrun('git rev-parse', ret_code=True)
    if code != 0:
        raise OSError("Must be inside a git repository to work")
    # change to root of git repository
    up = rev_parse('--show-cdup')
    if up != '':
        os.chdir(up)
    
def main():
    usage = 'Usage: %prog [options] arg'
    parser = OptionParser(usage)
    parser.add_option("-a","--add", dest="add", nargs=2, help="Adding new repository")
    parser.add_option("-i","--include", dest="include", help="Filter repository including files")
    parser.add_option("-x","--exlude", dest="exclude", help="Filter repository including files")
    parser.add_option("-f","--fetch", dest="fetch",help="Clone/Update repo")
    parser.add_option("-p","--push", dest="push", help="Push repos")
    parser.add_option("-c","--clone", dest="clone", nargs=2, help="Push repos")
    
    (options, args) = parser.parse_args()

    print options,args
    if options.add and ( options.fetch or options.push or options.clone):
        print "ups"
    
    to_git_root()
    if options.add: 
        add(*options.add)

    if options.fetch:
        fetch(options.fetch, options.include, options.exclude)

    if options.push:
        push(options.push)

    if options.clone:
        add(*options.clone)
        fetch(options.clone[0], options.include, options.exclude)


if __name__ == '__main__':
    main()
